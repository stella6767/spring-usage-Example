package com.example.jpademo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JpademoApplication {

    public static void main(String[] args) {
        SpringApplication.run(JpademoApplication.class, args);
    }

}


/**
 * 스프링 컨테이너 + JPA의 기본전략
 * 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
 * 트랜잭션의 범위와 영속성 컨텍스트의 생존범위가 같다는 뜻이다.
 * 트랜잭션이 시작되면, 영속성 컨텍스트를 생성하고, 트랜잭션이 끝나면, 영속성 컨텍스트를 종료한다.
 * 같은 트랜잭션 안에는 항상 같은 영속성 컨텍스트에 접근한다.
 * 주의할 점은 하나의 트랜잭션 안에 쿼리를 수행해서 결과를 바꿨다 하더라도 같은 트랜잭션 안에 수정된
 * 결과를 조회해도 변경된 값이 조회되지는 않음.
 * 트랜잭션이 달린 메서를 호출하면, 스프링의 트랜잭션 aop 가 먼저 동작, aop는 대상 메서드를 호출하기 전에
 * 트랜잭션을 시작하고, 대상 메서드가 종료되면, 트랜잭션을 커밋하면서 종료한다. 이때 트랜잭션을 커밋하면
 * JPA는 영속성 컨텍스트를 플러시해서 변경 내용을 DB에 반영한 후, DB 트랜잭션을 커밋한다.
 * 만약 예외가 발생하면 트랜잭션을 롤백하고 종료하는데, 이 때는 플러시를 호출하지 않는다.
 *
 * 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용하기 때문에, 여러 스레드에서 동시에 요청이 와서
 * 같은 엔티티매니저를 사용해도, 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다. 따라서 멀티스레드에 안전
 * 개발자는 편하게 동시성 같은 문제 신경쓰지 않고, 싱글쓰레드 작업하는 것처럼 작업하면 된다.
 */


/**
 * 변경감지 지능은 영속성 컨텍스트가 살아있는 서비스 레이어(트랜잭션 범위)까지만 동작하고,
 * 영속성 컨텍스트가 종료된 프리젠테이션 계층에서는 동작하지 않는다.
 * 준영속 상태의 가장 골치아픈 점은 지연 로딩 기능이 동작하지 않는다는 점이다.
 * 예를 들어 뷰를 랜더링할때, 연관된 엔티티도 함께 사용해야 하는데, 지연로딩으로 설정해서 프록시 객체로
 * 조회했다고 치면, 실제 데이터를 불러오려고 초기화를 시도한다. 하지만 준영속 상태는 영속성
 * 컨텍스트가 없으므로 lazyinitializationException 이 발생한다.. (실제로 내가 JPA에 대해 잘 모르고 시도했던
 * 프로젝트 대부분의 에러는 이 에러...)
 *
 * 준영속 상태의 지연로딩 문제를 해결하는 방법은 크게 2가지가 있다.
 * 1. 뷰가 필요한 엔티티를 미리 로딩해두는 방법
 * 2. OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법
 *
 *
 * 1번 방법은 크게 3가지 경로가 있는데
 * 1. 글로벌 패치 전략 수정(비추..),사용하지 않는 엔티티를 로딩할 수 있음. N+1 문제 발생
 * JPA가 JPQL을 분석해서 SQL을 생성할 때는 글로벌 패치 전략을 참고하지 않고, 오직 JPQL 자체만 사용
 * 만약 조회한 엔티티가 10개면 연관된 엔티티를 조회하는 쿼리도 10번 실행한다. 이처럼 처음 조회한 데이터
 * 수만큼 다시 다시 쿼리를 수행하는 것을 n+1 문제라 한다.
 * 2. JPQL 패치 조인
 * 패치 조인이 N+1 문제의 대안이긴 하지만, 래파지토리 메서드가 필요이상으로 늘어날 수 있다.
 * 예를 들어, 화면 A는 엔티티 하나의 정보만 필요하고, 화면 B는 그 엔티티와 연관된 엔티티 정보까지 필요하다면
 * 레파지토리에 각각 알맞는 2개의 메서드를 만들어야 한다.
 * 3. 강제로 초기화
 * 예를 들어 order가 엔티티가 member가 order에 연관된 엔티티컬렉션이라고 치면, 트랜잭션이 걸려있는 서비스메서드에서
 * order.gerMember().getName() 까지 호출하는 거다. order.getMember()까지만 호출하면, 단순히 프록시 객체만 반환하지만
 * member.getName()처럼 실제 값을 사용하는 시점에는 초기화된다.
 * 단점은 위처럼 프록시를 초기화하는 역할을 서비스 레이어가 담당하면, 뷰가 필요한 엔티티에 따라 서비스 레이어의
 * 로직을 변경해야한다. 프레젠테이션 계층이 서비스 계층을 침범하는 상황이다. 따라서 둘 사이를 연결짓는 하나의 레이어가 더 필요한데
 * 이를 FACADE Layer라 한다. 하지만 굳이 레이어를 하나 더 만들어야 되나.. 단순히 서비스 레이어를 호출하는 위임코드만 있을 것인데
 *
 *
 *
 * 2번 방법 OSIV
 * 결국 모든 문제는 엔티티가 프렌젠테이션 레이어(View) 에서 준영속 상태이기 때문에 발생한다.
 * 영속성 컨텍스트를 뷰까지 살아있게 열어두면 뷰에서도 지연로딩을 사용할 수 있다.
 * 이를 Open Session In View라 한다.
 * 1. 요청 당 트랜잭션: 클라이언트의 요청이 들어오자마자 서블릿 필터나 인터셉터에서, 트랜잭션을 시작하고,
 * 요청이 끝날 때 트랜잭션을 끝내는 것이다. 문제점은 만약 컨트롤러에서 엔티티 상태를 변경해서 뷰에 넘겨주면
 * 뷰를 랜더링한 후에 트랜잭션을 커밋한다. 그러면 영속성 컨텍스트가 플러시되면서 DB 상태도 바뀌게 된다.
 * DB 상태는 유지하면서 단순히 뷰에서 보여지는 것만 다른 상태를 보여주려할 때 심각한 문제점을 발생한다.
 * 이걸 방지하려면, 프렌젠테이션 계층에서 엔티티를 수정하지 못하게 막아야 한다.
 * 1. 엔티티를 읽기 전용 인터페이스로 제공
 * 2. 엔티티 래핑
 * 3. DTO만 반환
 * 위의 방법 모두 코드량이 상당히 늘어난다.. 따라서 요청 당 트랜잭션 방법은 안 하는 추세
 *
 * 2. 스프링 OSIV
 * 최근에는 위의 문제점을 어느정도 보완해서 비즈니스계층에서만 트랜잭션을 유지하는 방식의 OSI 를 사용한다/
 * client 요청이 들어오면 영속성 컨텍스트를 생성한다. 이때 트랜잭션은 시작하지 않는다.
 * 서비스 레이어에서 트랜잭션을 시작할 떄, 미리 생성된 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.
 * 서비스 계층이 끝나면, 트랜잭션을 커밋하고, 영속성 컨텍스트를 플러시한다. 트랜잭션은 끝내지만 영속성 컨텍스트는 종료하지 않는다/
 * 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.
 * 서블릿 필터나, 스프링 인터셉터로 요청이 들어오면 영속성 컨텍스트를 종효한다. 이때 플러시를 호출하지 않고 바로 종료한다.
 * 영속성 컨텍스트는 트랜잭션 범위 안에서만 엔티티를 조회하고 수정할 수 있다.
 * 영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회만 할 수 있다. 이것을 nontransactional reads 라 한다.
 * 스프링이 제공하는 OSIV를 사용하면 프레젠테이션 레이어에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.
 * 그리고 트랜잭션 없이 읽기를 사용해서 지연로딩 기능이 가능하다.
 * 또한 영속성 컨텍스트의 변경 내용을 DB에 반영하려면, 영속성 컨텍스트를 플러시해야 하는데, 트랜잭션을 사용하는
 * 서비스 레이어에서 트랜잭션이 커밋되면서 이미 플러시해버렸다. 그리고 스프링이 제공하는 OSIV는 요청이 끝나면,
 * 플러시를 호출하지 않고, em.close() 로 영속성 컨텍스트만 종료해 버리므로 플러시가 일어나지 않는다. 따라서
 * 서비스 범위(트랜잭션) 바깥에서 엔티티의 상태를 변경하고 뷰단에 돌려줘도 DB에 상태가 바뀌지 않는다! ㅎㅎ
 *
 * 주의사항: 스프링 OSIV를 사용하면, 프레젠테이션 레이어에서 엔티티를 수정해도 DB에 반영되지 않지만, 수정한 직후
 * 트랜잭션을 시작하는 서비스 계층을 호출할 경우 문제가 발생한다. 예를 들어 컨트롤러에서 엔티티를 수정하고
 * 다시 서비스 메서드를 호출하고 뷰에 리턴 시.. 문제를 해결하는 단순한 방법은 트랜잭션이 있는 비즈니스 로직을
 * 모두 호출하고 나서. 엔티티를 변경하면 된다. 스프링 OSIV는 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있으
 * 므로 이런 문제가 발생한다. OSIV의 단점들은 생략하도록 하겠다.
 */


/**
 * 트랜잭션의 격리수준 (ACID)
 * 원자성: 트랜잭션 내의 작업들은 마치 하나의 작업처럼 모두 성공하거나 실패
 * 일관성: 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
 * 격리성: 동시에 실행되는 트랜잭션드이 서로에게 영향을 못 미치도록 격리한다.
 * 지속성: 트랜잭션이 성공하면 그 결과가 항상 기록되어야 한다.
 *
 *
 * 문제는 격리성인데 격리성을 지키려면, 트랜잭션을 거의 차례대로 실행해야 한다. 동시성 처리 성능이 나빠짐
 * 트랜잭션 격리 수준은 4단계로 나뉜다.
 * READ_UNCOMMITED, READ_COMMITTED, REPEATABLE_READ, SERIALLZABLE 왼쪽이 가장 격리 수준이 높음
 * 격리 수준이 낮을 수록 동시성이 증가하지만, 다양한 문제가 발생한다.
 *
 * JPA는 DB 트랜잭션 격리 수준을 READ_COMMITED 정도로 가정한다. 만약 일부 로직에 더 높은 격리수준이 필요하면
 * 낙관적 락과 비관적 락 중 하나를 사용해야 한다. @Version
 * 낙관적 락: 트랜잭션 대부분이 충돌이 발생하지 않는다고 가정, 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다.
 * 비관적 락: 반대의 가정으로 우선 락을 걸고 보는 방법이다. 락을 걸어도 문제가 발생할 여지가 있는데
 * 사용자 A와 B가 동시에 같은 데이터를 수정했을 때, 결과적으로 나중에 완료한 사용자 B의 수정사항만 남게 된다.
 * 이것을 두 번의 갱신 분실 문제라 한다.
 * 이때는 3가지 선택방법이 있다.
 * 1. 마지막 커밋만 인정하기 (B의 내역만 인정) = default
 * 2. 최초커밋만 인정(A가 수정을 이미 완료했으므로, B가 수정할 때 오류가 발생)
 * 3. 충돌하는 갱신 내용 병합- 사용자 A와 사용자 B의 수정 내역을 병합한다.
 */